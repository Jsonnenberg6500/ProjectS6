<!DOCTYPE html>
<html>
<head>
	<title>Kevin's Logbook</title>
    <link rel="stylesheet"
          type="text/css"
          href="css/kevin-logbook.css" />
</head>
<body>
    <h1>Kevin's Logbook</h1>
    <img id=selfie src="images/kevin.png" width="200px">
    <div id="WeeklyBorder">
        <h2>Week 1</h2>
            <ul>
                <li>Created project schedule</li>
                <li>Started Phase 1 test plan</li>
                <li>Tested bus and PCAN adapters using PCAN-view as a group.  All nodes on the bus are operational</li>
                <li>Started writing code for closed loop feedback testing as a group</li>
            </ul>
    </div>
    <div id="WeeklyBorder">
	<h2>Week 2</h2>
    
        <ul>
            <li>Inherited CAN protocol designed by Tommy and his group</li>
            <li>Completed detailed testing plan document for all Phase one validation requirements.  Test is broken into two main sections:
                <ol>
                    <li>Call station and Elevator Car Testing
                        <ul>
                            <li>Testing up/down switches and lights of each call station</li>
                            <li>Testing open/close switches and lights of the elevator car</li>
                            <li>Testing the floor slection switches and lights of the elevator car</li>
                        </ul>
                    </li>
                    <li>System Level Testing
                        <ul>
                            <li>Testing elevator system to ensure it covers at least three floors, with one CAN node per floor</li>
                            <li>Testing the system capability to detect the location of the elevator car (with the distance sensor) and its ability to distribute this information to all call-stations for displaying on the appropriate displays</li>
                            <li>Ensuring the system an detect up/down requests at any floor and switch on the respective LED</li>
                            <li>Ensuring the system can detect floor selection at any floor and switch on the respective LED</li>
                            <li>Ensuring the system can detect a door open/close request at any floor and switch on the repective LED</li>
                        </ul>
                    </li>
                </ol>           
            </li>
            <li>Helped Ovi and James debug code for sending/receiving via CAN bus between two Axmans</li>
        </ul>
    </div>
    <div id="WeeklyBorder">
        <h2>Week 3</h2>
        <ul>
            <li>Got filtering working (multiple filters can now be set for each node)
            <ul>
                <li>Issue was with that we used code from the AN3034 appnote for sending and code from Bill (Stefanuk) for receiving.  It turns out that we were applying filters in the CANinit() function from the appnote and <b><i>again</i></b> in Bill's MSCANlisten().  The second time we applied the filter we overwrote the previous filters that were applied. </li>
                <li>After solving this issue we are able to apply multiple filters and have confirmed that sending </li></ul></li>
            <li>Started setting up seperate projects for each node type with the appropriate filters.  Want to have a header file common to all nodes that defines interconnection of the system (filters, etc)</li>
        </ul>
    </div>
    
    <h2>Week 4</h2>
	   <ul>
            <li>Created state machine based on a FIFO queue.  Need to confirm/chat with group members to make sure that my design is okay.  In a rough outline:
           <ul>
                <li>There will be 4 states: (1) FLOOR 1; (2) FLOOR 2; (3) FLOOR 3; (4) MOVING</li>
                <li>Transitions between states will occur based on data popped from a stack/FIFO queue:
               <ul>
                    <li>As requests are received for floor navigation from each floor or the elevator controller, they will be pushed onto the queue.  The supervisory controller will ensure that no identical floor requests will be stored consecutively (i.e., if the incoming floor request is the same as the last pushed onto the stack, it will be ignored)</li>
                    <li>The supervisory controller then moves between states by popping from the stack</li></ul></li>
                <li>Possible issues: this does not consider the state of the door open/closing.  There should possibly be an intermediate state between (any of the) FLOOR and MOVING states:
               <ul>
                    <li>Once the state transitions from MOVING to some FLOOR, it should enter a WAITING state where the door is intially assumed open.  Then, before moving to the next floor (indicated by popping data from the stack), it waits for the door to close.  This brings to light several questions regarding my current design of the state machine:
                        <ol>
                        <li>Should there be addional OPEN/CLOSED states, within the WAITING state?
                            <ul>
                                <li><b>Solution 1:</b> No additional states: the door is initially considered open upon arrival in the WAITING state.  An item is popped immediately and the supervisory controller is already aware of its next transition, but it waits on a message indicating the door has closed before transitioning.</li>
                                <li><b>Solution 2:</b> Maybe we could replace the WAITING state with OPEN and CLOSED states?</li></ul></li>
                        <li>What happens when the Car Controller requests a move to a floor and there is an item in the stack waiting to be popped?  How is this handled?
                            <ul>
                                <li>Example:  <em>Floors 1 and 2 have both called the elevator respectively, so the stack contains two items to be popped (FLOOR 1 will be popped first).  The elevator is currently at floor 3 where it has just picked up a person who requests floor 2 (on the Car Controller).  Where does the car go? Does their reqest get pushed onto the stack or is there priority for the person in the car already?</em></li></ul></li></ol>
                   </li>
                    </ul>
               </li>
                </ul>
           </li>
           <li>Started thinking about how we will interface the Linux-based Supervisory Controller with the PCAN interface. Considered Python for ease of implementation (can be done with prewritten libraries) but I have never programmed in Python so the learning curve will be more of a hinderance than the benefits could provide :(
           <ul>
               <li>
               Instead, will use the C++ libraries/API that are available from PEAK-Systems (maker of the PCAN).  I ran into some installation issues while trying to install the libraries at home.  I am hoping this will be remedied once I have the device connected to the computer.  If not, I will need to ask Tommy or Riley who I believe have this working already.
               <ul>
                   <li><em>The issue was that I did not have a required library installed: <b>libpopt-dev package</b>, which was specified in the driver's user manual under System Requirements.  This was installed using 'sudo apt-get install libpopt-dev'.</em></li></ul></li></ul></li>
           <li>Established communication between Linux VM (terminal) and Windows host (PCAN-view) over CAN-bus.  Steps followed are outlined on <a href="www.peak-system.com/forum/viewtopic.php?f=59&t=256"> this </a> blog post (thanks Riley!). Just in case this site is ever unavailable, these were the basic steps after installing the drivers and libraries:
           <ul>
               <li>Load the driver/module: <em>"sudo modprobe pcan"</em></li>
               <li>Check that the driver was installed properly: <em>"cat /proc/pcan"</em></li>
               <li>Change baud rate (250kbit/s in this example): <em>"echo "i 0x011C e" > /dev/pcan32"</em></li>
               <li>Observe incoming CAN messages: <em>"cat /dev/pcan32"</em></li></ul></li> 
    </ul>
    
	<h3>Navigation</h3>
		<nav>
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="project-plan.html">Project Plan</a></li>
				<li><a href="james-logbook.html">James' Log Book</a></li>
				<li><a href="kevin-logbook.html">Kevin's Log Book</a></li>
				<li><a href="ovi-logbook.html">Ovi's Log Book</a></li>
			</ul>
		</nav>
</body>
</html>